# -*- coding: utf-8 -*-
"""tr_6_4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vKmTN_4UeCq0PX8_mJvcgttDdn3pRR_e

A. Родословная: подсчет уровней
"""

lines=open('input.txt','r').readlines()
n=int(lines[0].strip())

name_num = {}
descs=set()
pars=set()

j=0
for i in range(1,n):
    if lines[i].split()[0] not in name_num:
        name_num[lines[i].split()[0]]=j
        j+=1
    if lines[i].split()[1] not in name_num:
        name_num[lines[i].split()[1]]=j
        j+=1
    descs.add(lines[i].split()[0])
    pars.add(lines[i].split()[1])

num_name = { ind : name for name, ind in name_num.items() }

dif=list(set(name_num.keys()) - descs)
main_par = name_num[dif[0]]


edges=[ [] for i in range(n) ]
for i in range(1,n):
    des = name_num[lines[i].split()[0]] # потомок
    par = name_num[lines[i].split()[1]] # родитель
    edges[par].append(des)

dist = [-1] * n
def dfs(v, h):
    if dist[v]==(-1):
        dist[v]=h
    for to in edges[v]:
        dfs(to, h+1)

dfs(main_par,0)

res = [ [ num_name[i], dist[i]] for i in range(n) ]
res = sorted(res, key = lambda x: x[0])
for i in range(n):
    print(*res[i])

"""B. Родословная: число потомков"""

import sys

sys.setrecursionlimit(100000)

lines=open('input.txt','r').readlines()
n=int(lines[0].strip())

name_num = {}
descs=set()
pars=set()

j=0
for i in range(1,n):
    if lines[i].split()[0] not in name_num:
        name_num[lines[i].split()[0]]=j
        j+=1
    if lines[i].split()[1] not in name_num:
        name_num[lines[i].split()[1]]=j
        j+=1
    descs.add(lines[i].split()[0])
    pars.add(lines[i].split()[1])

num_name = { ind : name for name, ind in name_num.items() }

dif=list(set(name_num.keys()) - descs)
main_par = name_num[dif[0]]


edges=[ [] for i in range(n) ]
for i in range(1,n):
    des = name_num[lines[i].split()[0]] # потомок
    par = name_num[lines[i].split()[1]] # родитель
    edges[par].append(des)

dist = [-1] * n
t_in = [-1] * n
t_out = [-1] * n
time=0

def dfs(v, h):
    global time
    time += 1
    t_in[v] = time
    if dist[v]==(-1):
        dist[v]=h
    for to in edges[v]:
        dfs(to, h+1)
    t_out[v] = time

dfs(main_par,0)

res = [ [ num_name[i], t_out[i] - t_in[i]] for i in range(n) ]
res = sorted(res, key = lambda x: x[0])
for i in range(n):
    print(*res[i])

"""C. Родословная: LCA"""

import sys
sys.setrecursionlimit(100000)

lines=open('input.txt','r').readlines()
lines = [line.strip() for line in lines]
lines = [line for line in lines if line]
n=int(lines[0].strip())
num_q=len(lines)-n

name_num = {}
descs=set()
pars=set()

j=0
for i in range(1,n):
    if lines[i].split()[0] not in name_num:
        name_num[lines[i].split()[0]]=j
        j+=1
    if lines[i].split()[1] not in name_num:
        name_num[lines[i].split()[1]]=j
        j+=1
    descs.add(lines[i].split()[0])
    pars.add(lines[i].split()[1])

num_name = { ind : name for name, ind in name_num.items() }

dif=list(set(name_num.keys()) - descs)
main_par = name_num[dif[0]]


edges=[ [] for i in range(n) ]
for i in range(1,n):
    des = name_num[lines[i].split()[0]] # потомок
    par = name_num[lines[i].split()[1]] # родитель
    edges[par].append(des)

dist = [-1] * n
t_in = [-1] * n
t_out = [-1] * n
time=0

ancs=[-1] * n
ancs[main_par]=main_par

def dfs(v, h):
    global time
    time += 1
    t_in[v] = time
    if dist[v]==(-1):
        dist[v]=h
    for to in edges[v]:
        ancs[to]=v
        dfs(to, h+1)
    t_out[v] = time

dfs(main_par,0)

def is_anc(v, req): # req предок для v?
    return t_in[req] <= t_in[v] <=  t_out[v] <= t_out[req]


def rev_dfs(u,v):
    if is_anc(u,v):
        return v
    if is_anc(v,u):
        return u

    while not is_anc(u,v): # пока v не предок для u, двигаем v вверх по дереву
        v = ancs[v]
    return v

for i in range(n, n+num_q):
    u = name_num[lines[i].split()[0]]
    v = name_num[lines[i].split()[1]]
    print(num_name[rev_dfs(u,v)])

"""D. Бинарное дерево (вставка, поиск, обход)"""

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

root=None

def add_node(v: int, node: TreeNode):
    if node is None:
        print('DONE')
        return TreeNode(val=v)

    if node.val == v:
        print('ALREADY')
        return node

    if v < node.val:
        node.left = add_node(v, node.left)
    elif v > node.val:
        node.right = add_node(v, node.right)

    return node

def search_node(v: int, node: TreeNode):
    if node is None:
        print('NO')
        return

    if node.val == v:
        print('YES')
        return

    if v < node.val:
        search_node(v, node.left)
    elif v > node.val:
        search_node(v, node.right)

    return


def print_tree(node: TreeNode, depth: int = 0):
    if node is None:
        return

    print_tree(node.left, depth + 1)

    print('.' * depth + str(node.val))

    print_tree(node.right, depth + 1)


lines=open('input.txt','r').readlines()
lines = [line.strip() for line in lines]
lines = [line for line in lines if line]

for line in lines:
    if len(line.split())==1:
        print_tree(root)

    if len(line.split())==2:
        opn = line.split()[0]
        n = int(line.split()[1])

        if opn == 'ADD':
            root = add_node(n, root)
        elif opn == 'SEARCH':
            search_node(n, root)

root.left.left.val

"""E. Размер поддеревьев"""

lines=open('input.txt','r').readlines()
lines = [line.strip() for line in lines]
lines = [line for line in lines if line]

n = int(lines[0])
edges = [ [] for i in range(n)]
for i in range(1,n):
    u, v = list(map(int,lines[i].split()))
    u -= 1
    v-= 1
    edges[u].append(v)
    edges[v].append(u)

t_in = [-1] * n
t_out = [-1] * n
time_diff = [-1] * n
time=0

used = [False] *n

def dfs(v):
    used[v] = True
    global time
    time += 1
    t_in[v] = time

    for to in edges[v]:
        if used[to] == False:
            dfs(to)

    t_out[v] = time

dfs(0)

for i in range(n):
    time_diff[i] = t_out[i] - t_in[i] + 1

print(*time_diff)

"""F. Бюрократия"""

lines=open('input.txt','r').readlines()
n = int(lines[0].strip())

if n==1:
    print(1)
else:
    a = list(map(int, lines[1].split()))

    edges = [[] for i in range(n) ]
    for i in range(n-1):
        edges[a[i]-1].append(i+1)

    ans = [0] * n
    t_in = [0] * n
    t_out = [0] * n
    time_diff = [0] * n
    time = 0

    def dfs(v):
        global time
        time += 1
        t_in[v] = time

        for to in edges[v]:
            dfs(to)

        t_out[v] = time
        time_diff[v] = t_out[v] - t_in[v] # посчитали число потомков каждой вершины

        desc_sum = 0
        for to in edges[v]:
            desc_sum += ans[to]

        ans[v] = desc_sum + time_diff[v] + 1

    dfs(0)

    print(*ans)

"""G. Дятлы"""

import sys
sys.setrecursionlimit(10000000)

def sol():
    lines=open('17.txt','r').readlines()
    lines = [line.strip() for line in lines]
    lines = [line for line in lines if line]

    n, m, k = list(map(int,lines[0].split()))

    if m > n - 1:
        return 0

    edges=[ [] for i in range(n) ]

    for i in range(1, m+1):
        u = list(map(int,lines[i].split()))[0] - 1
        v = list(map(int,lines[i].split()))[1] - 1
        edges[u].append(v)
        edges[v].append(u)

    used=[False]*n
    comps=[]
    comp=[]
    def dfs(v, par):
        used[v]=True
        comp.append(v)
        for to in edges[v]:
            if not used[to]:
                if not dfs(to, v):
                    return False
            elif used[to]:
                if to != par:
                    return False # нашелся цикл
        return True

    for v in range(n): # одиночки тоже считываются
        comp=[]
        if not used[v]:
            if dfs(v, -1):
                comps.append(comp)
            else:
                return 0
        comp=[]


    for i in range(len(comps)): # получаем список гусениц
        for v in comps[i]:
            if len(edges[v]) >= 3:
                nbs_not_leafs  =0
                for to in edges[v]:
                    if len(edges[to]) > 1:
                        nbs_not_leafs += 1

                if nbs_not_leafs > 2:
                    return 0

    N = 1000001
    fact = [1] * N
    for i in range(1, N):
        fact[i] = fact[i-1] * i % k

    ans = 1
    alones = 0
    for i in range(len(comps)):
        if len(comps[i]) == 1:
            alones += 1
        elif len(comps[i]) == 2:
            ans *= 2
        elif len(comps[i]) == 3:
            ans *= 4
        elif len(comps[i]) > 3:
            cnt = 0
            for v in comps[i]:
                if len(edges[v]) > 1:
                    cnt += 1
                    cur = 0
                    for to in edges[v]:
                        if len(edges[to])==1:
                            cur+=1
                    ans *= fact[cur] % k

            if cnt > 1:
                ans *= 4
            else:
                ans *= 2


    ans *= fact[len(comps)-alones] # перестановки графов

    in_graph = n - alones

    if alones != 0:
        # ans *= (in_graph + 2) % k
        for i in range(alones):
            ans = (ans * (in_graph + 2 + i)) % k


    return ans % k

print(sol())

"""H. Вершинно-реберное покрытие дерева"""

import sys
sys.setrecursionlimit(100000000)

lines=open('input.txt','r').readlines()
n = int(lines[0].strip())

if n == 1:
    print(int(lines[1].strip()), 1)
    print(1)

else:

    edges=[ [] for i in range(n) ]

    for i in range(1,n):
        u = list(map(int,lines[i].split()))[0] - 1
        v = list(map(int,lines[i].split()))[1] - 1
        edges[u].append(v)
        edges[v].append(u)

    a = list(map(int,lines[n].split()))

    dp  = [ [0,0] for i in range(n) ] # [не отмечено, отмечено]

    def dfs(v, parent):
        global dp
        dp[v][0] = 0
        dp[v][1] = a[v]

        for to in edges[v]:
            if to == parent:
                continue
            dfs(to, v)

            dp[v][0] += dp[to][1]
            dp[v][1] += min(dp[to][0], dp[to][1])

    dfs(0,-1)

    del a

    ans = []

    res = min(dp[0][0], dp[0][1])

    def reconstr(v, parent, mark):
        dp[v][0], dp[v][1] = 0, 0
        if mark:
            ans.append(v+1)
            for to in edges[v]:
                if to != parent:
                    if dp[to][0] < dp[to][1]:
                        reconstr(to, v, False)
                    else:
                        reconstr(to, v, True)
        else:
            for to in edges[v]:
                if to != parent:
                    reconstr(to, v, True)

    if dp[0][1] <= dp[0][0]:
        reconstr(0, -1, True)
    else:
        reconstr(0, -1, False)


    print(res, len(ans))
    print(*ans)

"""Подход с dfs на стеке"""

file1 = open('input.txt','r')
lines=file1.readlines()
n = int(lines[0].strip())

if n == 1:
    print(int(lines[1].strip()), 1)
    print(1)
    file1.close()

else:

    edges=[ [] for i in range(n) ]

    for i in range(1,n):
        u = list(map(int,lines[i].split()))[0] - 1
        v = list(map(int,lines[i].split()))[1] - 1
        edges[u].append(v)
        edges[v].append(u)

    a = list(map(int,lines[n].split()))

    file1.close()

    dp  = [ [0,a[i]] for i in range(n) ] # [не отмечено, отмечено]

    used=[False]*n
    stack = []
    stack.append(0)

    order=[]
    par_for = [-1] * n # список родителей вершин, дерево подвешено за 0 вершину
    while stack:
        v = stack[-1]
        del stack[-1]

        used[v] = True
        for u in edges[v]:
            if not used[u]:
                par_for[u] = v
                stack.append(u)
        order.append(v)

    del edges

    for i in range(len(order)-1, -1, -1):
        v = order[i]

        u = par_for[v]
        if u != -1: # -1 соответствует корню
            dp[u][0] += dp[v][1]
            dp[u][1] += min(dp[v][0], dp[v][1])

    ans = []

    marked = [False] * n

    res = min(dp[0][0], dp[0][1])

    if dp[0][0] < dp[0][1]:
        marked[0] = False
    else:
        marked[0] = True
        ans.append(1)


    for i in range(len(order)):
        v = order[i]

        u = par_for[v]
        if u != -1:
            if not marked[u]:
                marked[v] = True
                ans.append(v+1)
            else:
                if dp[v][0] < dp[v][1]:
                    marked[v] = False
                else:
                    marked[v] = True
                    ans.append(v+1)

    print(res, len(ans))
    print(*sorted(ans))